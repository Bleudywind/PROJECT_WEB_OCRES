'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs');

var Ora = require('ora');

var path = require('path');

var atob = require('atob');

var fse = require('fs-extra');

var config = require('../config');

var helpers = require('../helpers');

var childProcess = require('child_process');

var AuthHandler = require('./auth-handler');

var CliStatus = require('../models/cli-status');

var HttpWrapper = require('../utils/http-wrapper');

var _loadPackageManager = require('./managers/load-package-manager');

var PublishHandler = /*#__PURE__*/function () {
  function PublishHandler() {
    var authHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new AuthHandler();

    _classCallCheck(this, PublishHandler);

    this.result = [];
    this.cwd = process.cwd();
    this.projectName = '';
    this.packageName = '';
    this.domainName = '';
    this.last = 0;
    this.sent = 0;
    this.endMsg = '';
    this.useFtp = true;
    this.test = false;
    this.useGitlab = false;
    this.currentBranch = '';
    this.packageManager = null;
    this.isWindows = process.platform === 'win32';
    this.backendTechnology = undefined;
    this.options = {
      port: config.port,
      hostname: config.host,
      path: '/project/publish',
      method: 'POST'
    };
    this.authHandler = authHandler;
    this.setAuthHeader();
  }

  _createClass(PublishHandler, [{
    key: "setAuthHeader",
    value: function setAuthHeader() {
      this.result = this.authHandler.result;
      this.options.headers = this.authHandler.headers;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }, {
    key: "setArgs",
    value: function () {
      var _setArgs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(args) {
        var backendTechnology, technologies;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.useFtp = args.some(function (arg) {
                  return arg === '--ftp';
                });
                this.test = args.some(function (arg) {
                  return ['-t', '--test'].includes(arg);
                });
                backendTechnology = args.find(function (arg) {
                  return ['-b', '--backend'].includes(arg.split('=')[0]);
                });
                this.backendTechnology = backendTechnology ? backendTechnology.split('=')[1] : undefined;
                technologies = config.backendTechnologies;

                if (!(backendTechnology && !technologies.includes(this.backendTechnology))) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", Promise.reject({
                  Status: CliStatus.CLI_ERROR,
                  Message: "This technology is not supported. Allowed technologies: ".concat(technologies.join(', '))
                }));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setArgs(_x) {
        return _setArgs.apply(this, arguments);
      }

      return setArgs;
    }()
  }, {
    key: "handlePublishArgs",
    value: function handlePublishArgs() {
      var _this = this;

      if (this.useFtp) return Promise.resolve();
      return this.getSavedSettings().then(function () {
        return _this.checkIsGitlab();
      });
    }
  }, {
    key: "getSavedSettings",
    value: function () {
      var _getSavedSettings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var settingsPath, settings;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                settingsPath = path.join(this.cwd, '.mdb');
                _context2.prev = 1;
                _context2.next = 4;
                return helpers.deserializeJsonFile(settingsPath);

              case 4:
                settings = _context2.sent;

                if (settings.useGitlab) {
                  this.useGitlab = true;
                }

                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](1);

                if (!(_context2.t0.toString().toLowerCase().indexOf('unexpected token') !== -1)) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", Promise.reject({
                  Status: CliStatus.CLI_ERROR,
                  Message: '.mdb file is invalid. Please remove it and try again.'
                }));

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 8]]);
      }));

      function getSavedSettings() {
        return _getSavedSettings.apply(this, arguments);
      }

      return getSavedSettings;
    }()
  }, {
    key: "checkIsGitlab",
    value: function () {
      var _checkIsGitlab = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        var configPath, configContent, lines, remoteUrls, useGitlab;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                configPath = path.join(this.cwd, '.git', 'config');
                configContent = fs.existsSync(configPath) ? fs.readFileSync(configPath, 'utf8') : '';
                lines = configContent.replace(/\t/g, '').split('\n');
                remoteUrls = [];
                lines.forEach(function (line, index) {
                  if (line.startsWith('[remote')) {
                    var url = lines[index + 1].split(' = ')[1];
                    if (url.startsWith(config.gitlabUrl)) _this2.repoUrl = url;
                    remoteUrls.push(url);
                  }
                });

                if (!this.repoUrl) {
                  _context3.next = 14;
                  break;
                }

                if (!this.useGitlab) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", this.useFtp = false);

              case 8:
                _context3.next = 10;
                return helpers.showConfirmationPrompt('This project seems to be created on MDB Go GitLab server. Do you want to use our pipeline to publish your project now?');

              case 10:
                useGitlab = _context3.sent;
                if (useGitlab === false) this.useFtp = true;else this.useFtp = false;
                _context3.next = 15;
                break;

              case 14:
                this.useFtp = true;

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function checkIsGitlab() {
        return _checkIsGitlab.apply(this, arguments);
      }

      return checkIsGitlab;
    }()
  }, {
    key: "publish",
    value: function publish() {
      if (this.backendTechnology) {
        console.log('\n\x1b[34m%s\x1b[0m', 'Note:', 'In order for your app to run properly you need to configure it so that it listens on port 3000. It is required for internal port mapping. The real port that your app is available at, will be provided to you after successful publish.\n');
      }

      return this.useFtp ? this.uploadToFtp() : this.useGitlabPipeline();
    }
  }, {
    key: "uploadToFtp",
    value: function uploadToFtp() {
      var _this3 = this;

      return this.setPackageName().then(function () {
        return _this3.buildProject();
      }).then(function () {
        return _this3.uploadFiles();
      });
    }
  }, {
    key: "useGitlabPipeline",
    value: function useGitlabPipeline() {
      var _this4 = this;

      return this.getProjectStatus().then(function () {
        return _this4.getCurrentBranch();
      }).then(function () {
        return _this4.askAboutMerge();
      }).then(function () {
        return _this4.pullFromGitlab();
      }).then(function () {
        return _this4.createJenkinsfile();
      }).then(function () {
        return _this4.pushToGitlab();
      }).then(function () {
        return _this4.askAboutSaveSettings();
      });
    }
  }, {
    key: "getProjectStatus",
    value: function getProjectStatus() {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var gitStatus = childProcess.spawn('git', ['status'], _objectSpread({
          cwd: _this5.cwd
        }, _this5.isWindows && {
          shell: true
        }));
        gitStatus.stdout.on('data', function (data) {
          if (data.indexOf('nothing to commit, working tree clean') !== -1) {
            return resolve({
              Status: CliStatus.SUCCESS,
              Message: 'OK'
            });
          }

          return reject({
            Status: CliStatus.CLI_ERROR,
            Message: 'You have uncommited changes in your project, please commit and try again.'
          });
        });
        gitStatus.stderr.on('data', function (data) {
          return reject(data.toString());
        });
      });
    }
  }, {
    key: "getCurrentBranch",
    value: function getCurrentBranch() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        var gitBranch = childProcess.spawn('git', ['rev-parse', '--abbrev-ref', 'HEAD'], _objectSpread({
          cwd: _this6.cwd
        }, _this6.isWindows && {
          shell: true
        }));
        gitBranch.stdout.on('data', function (data) {
          _this6.currentBranch = data.toString().trim();
          return resolve();
        });
        gitBranch.stderr.on('data', function (data) {
          return reject(data.toString());
        });
      });
    }
  }, {
    key: "askAboutMerge",
    value: function () {
      var _askAboutMerge = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var answer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.currentBranch === 'master')) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                _context4.next = 4;
                return helpers.showConfirmationPrompt("Your currenct branch is ".concat(this.currentBranch, ". Do you want to merge it into master?"));

              case 4:
                answer = _context4.sent;

                if (!answer) {
                  _context4.next = 12;
                  break;
                }

                _context4.next = 8;
                return this.changeBranch();

              case 8:
                _context4.next = 10;
                return this.mergeBranch();

              case 10:
                _context4.next = 13;
                break;

              case 12:
                process.exit(0);

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function askAboutMerge() {
        return _askAboutMerge.apply(this, arguments);
      }

      return askAboutMerge;
    }()
  }, {
    key: "changeBranch",
    value: function changeBranch() {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        var gitCheckout = childProcess.spawn('git', ['checkout', 'master'], _objectSpread({
          cwd: process.cwd(),
          stdio: 'inherit'
        }, _this7.isWindows && {
          shell: true
        }));
        gitCheckout.on('error', function (error) {
          return reject(error);
        });
        gitCheckout.on('exit', function (code) {
          if (code === CliStatus.SUCCESS) {
            _this7.result.push({
              Status: CliStatus.SUCCESS,
              Message: 'Switched to branch master.'
            });

            return resolve();
          }

          return reject({
            Status: code,
            Message: 'Problem with git branch change.'
          });
        });
      });
    }
  }, {
    key: "mergeBranch",
    value: function mergeBranch() {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        var gitMerge = childProcess.spawn('git', ['merge', _this8.currentBranch], _objectSpread({
          cwd: process.cwd(),
          stdio: 'inherit'
        }, _this8.isWindows && {
          shell: true
        }));
        gitMerge.on('error', function (error) {
          return reject(error);
        });
        gitMerge.on('exit', function (code) {
          if (code === CliStatus.SUCCESS) {
            _this8.result.push({
              Status: CliStatus.SUCCESS,
              Message: "Branch ".concat(_this8.currentBranch, " merged into master")
            });

            return resolve();
          }

          return reject({
            Status: code,
            Message: 'Problem with git branch merge.'
          });
        });
      });
    }
  }, {
    key: "pullFromGitlab",
    value: function pullFromGitlab() {
      var _this9 = this;

      return new Promise(function (resolve, reject) {
        var gitPull = childProcess.spawn('git', ['pull', 'origin', 'master'], _objectSpread({
          cwd: process.cwd()
        }, _this9.isWindows && {
          shell: true
        }));
        var result;
        gitPull.stdout.on('data', function (data) {
          result = "\n".concat(data);
          console.log(result);
        });
        gitPull.stderr.on('data', function (data) {
          result = "\n".concat(data);
          console.error(result);
        });
        gitPull.on('exit', function (code) {
          if (code === CliStatus.SUCCESS || result.indexOf("Couldn't find remote ref master") !== -1) resolve();else reject({
            Status: code,
            Message: 'Problem with project fetching from GitLab.'
          });
        });
      });
    }
  }, {
    key: "createJenkinsfile",
    value: function () {
      var _createJenkinsfile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var created;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return helpers.createJenkinsfile(this.cwd);

              case 2:
                created = _context5.sent;
                _context5.t0 = created;

                if (!_context5.t0) {
                  _context5.next = 7;
                  break;
                }

                _context5.next = 7;
                return helpers.commitFile('Jenkinsfile', 'Add Jenkinsfile');

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function createJenkinsfile() {
        return _createJenkinsfile.apply(this, arguments);
      }

      return createJenkinsfile;
    }()
  }, {
    key: "pushToGitlab",
    value: function pushToGitlab() {
      var _this10 = this;

      return new Promise(function (resolve, reject) {
        var gitPush = childProcess.spawn('git', ['push', 'origin', 'master'], _objectSpread({
          cwd: process.cwd(),
          stdio: 'inherit'
        }, _this10.isWindows && {
          shell: true
        }));
        gitPush.on('error', function (error) {
          return reject(error);
        });
        gitPush.on('exit', function (code) {
          if (code === CliStatus.SUCCESS) {
            _this10.result.push({
              Status: code,
              Message: 'Success! Your project will be published using GitLab pipeline'
            });

            var options = {
              port: config.port,
              hostname: config.host,
              path: "/project/save/".concat(_this10.projectName),
              method: 'POST',
              data: {
                repoUrl: _this10.repoUrl
              },
              headers: _objectSpread(_objectSpread({}, _this10.authHandler.headers), {}, {
                'Content-Type': 'application/json'
              })
            };
            var http = new HttpWrapper(options);
            return http.post().then(function (res) {
              _this10.result.push(JSON.parse(res));

              return resolve();
            })["catch"](function (err) {
              return reject(err);
            });
          }

          return reject({
            Status: code,
            Message: 'Problem with project publishing.'
          });
        });
      });
    }
  }, {
    key: "askAboutSaveSettings",
    value: function () {
      var _askAboutSaveSettings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var save;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(this.useGitlab === false)) {
                  _context6.next = 5;
                  break;
                }

                _context6.next = 3;
                return helpers.showConfirmationPrompt('Do you want to use GitLab pipelines as a default publish method?');

              case 3:
                save = _context6.sent;
                if (save) this.saveSettings();else this.result = [{
                  Status: CliStatus.SUCCESS,
                  Message: 'Success! This time your project will be published using GitLab pipeline but we will not use it next time.'
                }];

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function askAboutSaveSettings() {
        return _askAboutSaveSettings.apply(this, arguments);
      }

      return askAboutSaveSettings;
    }()
  }, {
    key: "saveSettings",
    value: function () {
      var _saveSettings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var settingsPath, settings;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                settingsPath = path.join(this.cwd, '.mdb');
                _context7.prev = 1;
                _context7.next = 4;
                return helpers.deserializeJsonFile(settingsPath);

              case 4:
                settings = _context7.sent;
                settings.useGitlab = true;
                _context7.next = 8;
                return helpers.serializeJsonFile(settingsPath, settings);

              case 8:
                _context7.next = 10;
                return helpers.commitFile('.mdb', 'Add settings to .mdb config file');

              case 10:
                _context7.next = 15;
                break;

              case 12:
                _context7.prev = 12;
                _context7.t0 = _context7["catch"](1);

                if (_context7.t0.code === 'ENOENT') {
                  helpers.saveMdbConfig(settingsPath, JSON.stringify({
                    useGitlab: true
                  }), true);
                }

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[1, 12]]);
      }));

      function saveSettings() {
        return _saveSettings.apply(this, arguments);
      }

      return saveSettings;
    }()
  }, {
    key: "loadPackageManager",
    value: function () {
      var _loadPackageManager2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.isBackendOneOf('php')) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return");

              case 2:
                if (!(this.packageManager === null)) {
                  _context8.next = 6;
                  break;
                }

                _context8.next = 5;
                return _loadPackageManager(true, !this.useFtp);

              case 5:
                this.packageManager = _context8.sent;

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function loadPackageManager() {
        return _loadPackageManager2.apply(this, arguments);
      }

      return loadPackageManager;
    }()
  }, {
    key: "runTests",
    value: function () {
      var _runTests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this11 = this;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!this.test) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 3;
                return this.loadPackageManager();

              case 3:
                return _context9.abrupt("return", new Promise(function (resolve, reject) {
                  var test = _this11.packageManager.test();

                  test.on('error', function (error) {
                    return reject(error);
                  });
                  test.on('exit', function (code) {
                    return code === CliStatus.SUCCESS ? resolve({
                      Status: code,
                      Message: 'Success'
                    }) : reject({
                      Status: code,
                      Message: 'Tests failed'
                    });
                  });
                }));

              case 6:
                return _context9.abrupt("return", Promise.resolve());

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function runTests() {
        return _runTests.apply(this, arguments);
      }

      return runTests;
    }()
  }, {
    key: "setProjectName",
    value: function () {
      var _setProjectName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var packageJsonPath, packageJson;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                packageJsonPath = path.join(this.cwd, 'package.json');
                _context10.prev = 1;
                _context10.next = 4;
                return helpers.deserializeJsonFile(packageJsonPath);

              case 4:
                packageJson = _context10.sent;
                this.projectName = packageJson.name;
                this.domainName = packageJson.domainName || '';
                return _context10.abrupt("return", Promise.resolve());

              case 10:
                _context10.prev = 10;
                _context10.t0 = _context10["catch"](1);

                if (!(_context10.t0.code && _context10.t0.code === 'ENOENT' && !this.isBackendOneOf('php'))) {
                  _context10.next = 16;
                  break;
                }

                return _context10.abrupt("return", this.handleMissingPackageJson());

              case 16:
                if (!this.isBackendOneOf('php')) {
                  _context10.next = 20;
                  break;
                }

                _context10.next = 19;
                return this.setPhpProjectName();

              case 19:
                return _context10.abrupt("return");

              case 20:
                this.result = [{
                  Status: CliStatus.INTERNAL_SERVER_ERROR,
                  Message: "Problem with reading project name: ".concat(_context10.t0)
                }];
                return _context10.abrupt("return", Promise.reject(this.result));

              case 22:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[1, 10]]);
      }));

      function setProjectName() {
        return _setProjectName.apply(this, arguments);
      }

      return setProjectName;
    }()
  }, {
    key: "isBackendOneOf",
    value: function isBackendOneOf(tech) {
      return !!this.backendTechnology && this.backendTechnology.includes(tech);
    }
  }, {
    key: "setPhpProjectName",
    value: function () {
      var _setPhpProjectName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var metadataPath, metadataExists, projectMetadata, name;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                metadataPath = path.join(this.cwd, '.mdb');
                metadataExists = fs.existsSync(metadataPath);

                if (!metadataExists) {
                  _context11.next = 8;
                  break;
                }

                _context11.next = 5;
                return helpers.deserializeJsonFile(metadataPath);

              case 5:
                _context11.t0 = _context11.sent;
                _context11.next = 9;
                break;

              case 8:
                _context11.t0 = {};

              case 9:
                projectMetadata = _context11.t0;
                if (projectMetadata.domainName) this.domainName = projectMetadata.domainName;

                if (!projectMetadata.projectName) {
                  _context11.next = 14;
                  break;
                }

                this.projectName = projectMetadata.projectName;
                return _context11.abrupt("return");

              case 14:
                _context11.next = 16;
                return helpers.showTextPrompt('Enter project name', 'Project name must not be empty.');

              case 16:
                name = _context11.sent;
                this.projectName = name;

                if (!metadataExists) {
                  _context11.next = 24;
                  break;
                }

                projectMetadata.projectName = name;
                _context11.next = 22;
                return helpers.serializeJsonFile(metadataPath, projectMetadata);

              case 22:
                _context11.next = 25;
                break;

              case 24:
                fs.writeFileSync(metadataPath, JSON.stringify({
                  projectName: name
                }), 'utf8');

              case 25:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function setPhpProjectName() {
        return _setPhpProjectName.apply(this, arguments);
      }

      return setPhpProjectName;
    }()
  }, {
    key: "setPackageName",
    value: function () {
      var _setPackageName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var metadataPath, projectMetadata;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                metadataPath = path.join(this.cwd, '.mdb');
                _context12.prev = 1;
                _context12.next = 4;
                return helpers.deserializeJsonFile(metadataPath);

              case 4:
                projectMetadata = _context12.sent;
                this.packageName = projectMetadata.packageName || '';
                _context12.next = 11;
                break;

              case 8:
                _context12.prev = 8;
                _context12.t0 = _context12["catch"](1);
                this.packageName = '';

              case 11:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[1, 8]]);
      }));

      function setPackageName() {
        return _setPackageName.apply(this, arguments);
      }

      return setPackageName;
    }()
  }, {
    key: "buildProject",
    value: function () {
      var _buildProject = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var distPath, buildPath, packageJsonPath, packageJson, isAngular, isReact, isVue, angularJsonPath, angularJson, angularFolder, indexPath, indexHtml, toRename, token, _token$split, _token$split2, jwtBody, username, appJsPath, appJsFile, _appJsFile, regex, vueConfigFile, vueConfigContent, warning;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                distPath = path.join(this.cwd, 'dist');
                buildPath = path.join(this.cwd, 'build');
                packageJsonPath = path.join(this.cwd, 'package.json');

                if (!fs.existsSync(packageJsonPath)) {
                  _context13.next = 9;
                  break;
                }

                _context13.next = 6;
                return helpers.deserializeJsonFile(packageJsonPath);

              case 6:
                _context13.t0 = _context13.sent;
                _context13.next = 10;
                break;

              case 9:
                _context13.t0 = {};

              case 10:
                packageJson = _context13.t0;

                if (!(packageJson.scripts && packageJson.scripts.build)) {
                  _context13.next = 67;
                  break;
                }

                isAngular = packageJson.dependencies && !!packageJson.dependencies['@angular/core'];
                isReact = packageJson.dependencies && !!packageJson.dependencies.react;
                isVue = packageJson.dependencies && !!packageJson.dependencies.vue;
                _context13.next = 17;
                return this.loadPackageManager();

              case 17:
                if (!isAngular) {
                  _context13.next = 34;
                  break;
                }

                angularJsonPath = path.join(this.cwd, 'angular.json');
                _context13.next = 21;
                return helpers.deserializeJsonFile(angularJsonPath);

              case 21:
                angularJson = _context13.sent;
                _context13.next = 24;
                return helpers.buildProject(this.packageManager);

              case 24:
                angularFolder = path.join('dist', angularJson.defaultProject);
                indexPath = path.join(this.cwd, angularFolder, 'index.html');
                indexHtml = fs.readFileSync(indexPath, 'utf8');
                indexHtml = indexHtml.replace(/<base href="\/">/g, '<base href=".">');
                fs.writeFileSync(indexPath, indexHtml, 'utf8');
                toRename = path.join(this.cwd, angularFolder);
                fse.moveSync(toRename, buildPath, {
                  overwrite: true
                });
                fse.moveSync(buildPath, distPath, {
                  overwrite: true
                });
                _context13.next = 67;
                break;

              case 34:
                if (!isReact) {
                  _context13.next = 54;
                  break;
                }

                token = this.authHandler.headers.Authorization;
                _token$split = token.split('.'), _token$split2 = _slicedToArray(_token$split, 2), jwtBody = _token$split2[1];
                username = JSON.parse(atob(jwtBody)).name;
                appJsPath = path.join(this.cwd, 'src', 'App.js');

                if (fs.existsSync(appJsPath)) {
                  appJsFile = fs.readFileSync(appJsPath, 'utf8');
                  appJsFile = appJsFile.replace(/<Router/g, "<Router basename='/".concat(username, "/").concat(packageJson.name, "'"));
                  fs.writeFileSync(appJsPath, appJsFile, 'utf8');
                }

                packageJson.homepage = "https://".concat(config.projectsDomain, "/").concat(username, "/").concat(packageJson.name, "/");
                _context13.next = 43;
                return helpers.serializeJsonFile('package.json', packageJson);

              case 43:
                _context13.next = 45;
                return helpers.buildProject(this.packageManager);

              case 45:
                if (fs.existsSync(appJsPath)) {
                  _appJsFile = fs.readFileSync(appJsPath, 'utf8');
                  regex = new RegExp("<Router basename='/".concat(username, "/").concat(packageJson.name, "'"), 'g');
                  _appJsFile = _appJsFile.replace(regex, '<Router');
                  fs.writeFileSync(appJsPath, _appJsFile, 'utf8');
                }

                _context13.next = 48;
                return helpers.deserializeJsonFile(packageJsonPath);

              case 48:
                packageJson = _context13.sent;
                delete packageJson.homepage;
                _context13.next = 52;
                return helpers.serializeJsonFile('package.json', packageJson);

              case 52:
                _context13.next = 67;
                break;

              case 54:
                if (!isVue) {
                  _context13.next = 61;
                  break;
                }

                vueConfigFile = path.join(this.cwd, 'vue.config.js');

                if (!fs.existsSync(vueConfigFile)) {
                  vueConfigContent = 'module.exports = { publicPath: \'.\' }';
                  fs.writeFileSync(vueConfigFile, vueConfigContent, 'utf8');
                }

                _context13.next = 59;
                return helpers.buildProject(this.packageManager);

              case 59:
                _context13.next = 67;
                break;

              case 61:
                _context13.next = 63;
                return helpers.buildProject(this.packageManager);

              case 63:
                warning = "\nThis is not MDB JARV project and there is no guarantee that it will work properly after publishing.\nIn case of problems, please write to our support https://mdbootstrap.com/support/\n";
                console.log('\x1b[36m%s\x1b[0m', warning);

                if (!(!fs.existsSync(distPath) && !fs.existsSync(buildPath))) {
                  _context13.next = 67;
                  break;
                }

                return _context13.abrupt("return", Promise.reject({
                  Status: CliStatus.ERROR,
                  Message: 'Build folder not found.'
                }));

              case 67:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function buildProject() {
        return _buildProject.apply(this, arguments);
      }

      return buildProject;
    }()
  }, {
    key: "uploadFiles",
    value: function uploadFiles() {
      var _this12 = this;

      console.log('Publishing...');
      var spinner = new Ora({
        text: 'Uploading files'
      });
      spinner.start();
      return new Promise(function (resolve, reject) {
        if (_this12.backendTechnology) _this12.options.headers['x-mdb-cli-backend-technology'] = _this12.backendTechnology;
        _this12.options.headers['x-mdb-cli-project-name'] = _this12.projectName;
        _this12.options.headers['x-mdb-cli-package-name'] = _this12.packageName;
        _this12.options.headers['x-mdb-cli-domain-name'] = _this12.domainName;

        var _require = require('../helpers/archiver-wrapper'),
            archiveProject = _require.archiveProject;

        var archive = archiveProject('zip', {
          zlib: {
            level: 9
          }
        });
        var http = new HttpWrapper(_this12.options);
        var request = http.createRequest(function (response) {
          response.on('data', function (data) {
            _this12.endMsg = Buffer.from(data).toString('utf8');
          });
          response.on('end', function () {
            _this12.convertToMb(archive.pointer());

            spinner.succeed("Uploading files | ".concat(_this12.sent, " Mb"));

            _this12.result.push({
              'Status': response.statusCode,
              'Message': _this12.endMsg
            });

            if (response.statusCode === CliStatus.HTTP_SUCCESS) {
              _this12.result.push({
                'Status': CliStatus.SUCCESS,
                'Message': "Sent ".concat(_this12.sent, " Mb")
              });
            } else {
              _this12.result.push({
                'Status': response.statusCode,
                'Message': response.statusMessage
              });
            }

            resolve();
          });
          response.on('error', console.error);
        });
        archive.on('error', reject);
        archive.on('warning', console.warn);
        archive.on('progress', function () {
          _this12.convertToMb(archive.pointer());

          spinner.text = "Uploading files | ".concat(_this12.sent, " Mb");
        });
        archive.pipe(request);
        archive.glob('**', {
          cwd: _this12.cwd,
          ignore: ['node_modules/**', '.git/**', '.gitignore', 'Dockerfile', '.dockerignore', '.idea/**']
        });
        archive.finalize();
      });
    }
  }, {
    key: "convertToMb",
    value: function convertToMb(pointer) {
      var num = pointer / Math.pow(1024, 2);
      this.sent = num.toFixed(3);
    }
  }, {
    key: "handleMissingPackageJson",
    value: function handleMissingPackageJson() {
      var _this13 = this;

      return this.loadPackageManager().then(function () {
        return helpers.createPackageJson(_this13.packageManager, _this13.cwd);
      }).then(function (msg) {
        return _this13.result.push(msg);
      }).then(function () {
        return _this13.setProjectName();
      })["catch"](function (err) {
        _this13.result.push(err);

        _this13.result.push({
          'Status': CliStatus.ERROR,
          'Message': 'Missing package.json file.'
        });

        console.table(_this13.result);
        process.exit(1);
      });
    }
  }]);

  return PublishHandler;
}();

module.exports = PublishHandler;